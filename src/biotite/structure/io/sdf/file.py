# This source code is part of the Biotite package and is distributed
# under the 3-Clause BSD License. Please see 'LICENSE.rst' for further
# information.

__name__ = "biotite.structure.io.sdf"
__author__ = "Benjamin E. Mayer"
__all__ = ["SDFile"]

import datetime
from warnings import warn
import re
import numpy as np
from ...atoms import AtomArray, AtomArrayStack
import biotite.structure as struc
from ....file import TextFile, InvalidFileError
from ...error import BadStructureError
from ..ctab import read_structure_from_ctab, write_structure_to_ctab


# Number of header lines
N_HEADER = 3
DATE_FORMATS = ["%d%m%y%H%M", "%m%d%y%H%M"]


class SDFile(TextFile):
    """
    This class represents a file in SDF format, that is used to store
    structure information for small molecules. :footcite:`Dalby1992`
    The implementation here is based on the MOLFile and is basically an 
    extension of the MOLFile to als cover multiple models and meta information
    in the form of a dictionary.    
           
    
    References
    ----------
    
    .. footbibliography::
    
    Examples
    --------

    >>> from os.path import join
    >>> mol_file = MOLFile.read(join(path_to_structures, "molecules", "TYR.sdf"))
    >>> atom_array = mol_file.get_structure()
    >>> print(atom_array)
                0             N         1.320    0.952    1.428
                0             C        -0.018    0.429    1.734
                0             C        -0.103    0.094    3.201
                0             O         0.886   -0.254    3.799
                0             C        -0.274   -0.831    0.907
                0             C        -0.189   -0.496   -0.559
                0             C         1.022   -0.589   -1.219
                0             C        -1.324   -0.102   -1.244
                0             C         1.103   -0.282   -2.563
                0             C        -1.247    0.210   -2.587
                0             C        -0.032    0.118   -3.252
                0             O         0.044    0.420   -4.574
                0             O        -1.279    0.184    3.842
                0             H         1.977    0.225    1.669
                0             H         1.365    1.063    0.426
                0             H        -0.767    1.183    1.489
                0             H         0.473   -1.585    1.152
                0             H        -1.268   -1.219    1.134
                0             H         1.905   -0.902   -0.683
                0             H        -2.269   -0.031   -0.727
                0             H         2.049   -0.354   -3.078
                0             H        -2.132    0.523   -3.121
                0             H        -0.123   -0.399   -5.059
                0             H        -1.333   -0.030    4.784
    """
    
    def __init__(self):
        super().__init__()
        # empty header lines
        self.lines = [""] * N_HEADER
    
    def get_header(self):
        """
        Get the header from the SDF file.
        This is identical to the MOL file header as the basic information 
        per model is the same.
        This doesn't seem to work properly with files generated by
        openbabel. The datetime will be interpreted correctly but the 
        other fields might be of. If this information is realy wanted 
        one should access the acording line with sdf_file.lines[1].
        
        Returns
        -------
        mol_name : str
            The name of the molecule.
        initials : str
            The author's initialfilters.
        program : str
            The program name.
        time : datetime
            The time of file creation.
        dimensions : str
            Dimensional codes.
        scaling_factors : str
            Scaling factors.
        energy : str
            Energy from modeling program.
        registry_number : str
            MDL registry number.
        comments : str
            Additional comments.
        """
        mol_name        = self.lines[0].strip()
        initials        = self.lines[1][:2].strip()
        
        line1_split     = re.split(r'(\d+)',self.lines[1].strip())
        program         = self.lines[1][2:10].strip()
        program         = line1_split[0]
        
        time = None    
        if len(line1_split) > 1:
            
            time_parsing_succesfull = False
            msg_last = ""
            for format_i in DATE_FORMATS:
                try:

                    time = datetime.datetime.strptime(
                        line1_split[1][:10],
                                    
        #                ''.join([x for x in self.lines[1] if x.isdigit()])[
        #                    :10
        #                ],
#                        self.lines[1][10:20].strip()[:len(format_i)],
                        format_i
                    )
                    time_parsing_succesfull = True
                except:
                    time_parsing_succesfull = False
                    #msg = str(self.lines[1]) + " | " + str(line1_split)
                    #msg += " | " + str(line1_split[1][:9]) + " | "
                    msg_last = self.lines[1][10:20].strip()[:len(format_i)]
                    msg_last += "could not be interpreted as datetime"
                    
            if not time_parsing_succesfull:
                warn(msg_last)
                   
            
        dimensions      = self.lines[1][20:22].strip()
        scaling_factors = self.lines[1][22:34].strip()
        energy          = self.lines[1][34:46].strip()
        registry_number = self.lines[1][46:52].strip()
        comments        = self.lines[2].strip()
        return mol_name, initials, program, time, dimensions, \
               scaling_factors, energy, registry_number, comments

    def __get_model_lines(self):
        """
        Internal function used to derive indices where models in file
        start, loaction of M  END directive as well as $$$$.
        """
    
        mod_end_lines = [
            i for i in range(len(self.lines)) if '$$$$' in self.lines[i]
        ]
    
        mod_start_lines = [0] + [
            x + 1 for x in mod_end_lines[:-1]
        ]
            
        m_end_lines = [
            i for i in range(
                len(self.lines)
            ) if self.lines[i].startswith("M  END")
        ]   
        
        return mod_start_lines, m_end_lines, mod_end_lines       

    def set_header(self, mol_name, initials="", program="", time=None,
                   dimensions="", scaling_factors="", energy="",
                   registry_number="", comments=""):
        """
        Set the header from the SDF file.
        This is identical to the MOL file header as the basic information 
        per model is the same.
        
        Parameters
        ----------
        mol_name : str
            The name of the molecule.
        initials : str, optional
            The author's initials. Maximum length is 2.
        program : str, optional
            The program name. Maximum length is 8.
        time : datetime or date, optional
            The time of file creation.
        dimensions : str, optional
            Dimensional codes. Maximum length is 2.
        scaling_factors : str, optional
            Scaling factors. Maximum length is 12.
        energy : str, optional
            Energy from modeling program. Maximum length is 12.
        registry_number : str, optional
            MDL registry number. Maximum length is 6.
        comments : str, optional
            Additional comments.
        """
#        print("###START#SET#HEADER#TIME#SECTION###############################") 

        time_str=""
        for format_i in DATE_FORMATS:
            try:
                time_str = time.strftime(format_i)
                
#        if time is None or type(time) is type(datetime.datetime.now()):
#            time = datetime.datetime.now()
#            if self._format is not None:
#                time_str = time.strftime(self._format)
#            else:                
#                time_str = time.strftime(DATE_FORMATS[0])   

            except:
                pass         
    
        if len(time_str) == 0:
            time = datetime.datetime.now() 
            time_str = time.strftime(DATE_FORMATS[0])           
                      
#        print(time_str)            
            
#        print("###END#SET#HEADER#TIME#SECTION#################################")            
                        

        self.lines[0] = str(mol_name)
        self.lines[1] = (
            f"{initials:>2}"
            f"{program:>8}"
            f"{time_str:>10}"
            f"{dimensions:>2}"
            f"{scaling_factors:>12}"
            f"{energy:>12}"
            f"{registry_number:>6}"
        )
        self.lines[2] = str(comments)


    def get_structure(self):
        """
        Get an :class:`AtomArray` if it only contains one model
        or an :class:'AtomArrayStack' if it contains multiple models.
        
        Returns
        -------
        array : AtomArray, AtomArrayStack
            This :class: contains the optional ``charge``
            annotation and has an associated :class:`BondList`.
            All other annotation categories, except ``element`` are
            empty.
                                    
        """

        mod_start_lines, m_end_lines, mod_end_lines = self.__get_model_lines()
        assert(len(mod_end_lines) < len(self.lines))
        
        # if only $$$$ is forgotten in mol file add it
        if len(mod_end_lines) == 0 and len(m_end_lines) !=0:
            self.lines.append("$$$$")
            mod_lines = self.__get_model_lines()
            mod_start_lines, m_end_lines, mod_end_lines = mod_lines 
        
#        mod_start_lines = [0] + [x+1 for x in mod_end_lines[:-1]]
        
        if len(mod_end_lines) == 0 and len(m_end_lines) == 0:
            msg  = "Trying to get structure from empty file, or"
            msg += "M_END line is missing. \n"
            msg += "Lines where :: \n" + str(self.lines) + "\n\n"
            raise BadStructureError(msg)

        array_stack = []
        
        i_start = 0
        for i in range(len(mod_end_lines)):


            ctab_lines = self.lines[
                int(mod_start_lines[i]+3):int(m_end_lines[i])
            ]        
              
                
                    
            if len(ctab_lines) == 0:
                msg  = "File does not contain structure data"
                msg += "in model " + str(i) + "."
                raise InvalidFileError(msg)
            

            atom_array = read_structure_from_ctab(ctab_lines)                                       
            array_stack.append(atom_array)                        
            

        if len(mod_end_lines) == 1:        
            return array_stack[0]
        else:
            return struc.stack(array_stack)
            

    def set_structure(self, atoms):
        """
        Set the :class:`AtomArray` for the file.
        
        Parameters
        ----------
        array : AtomArray, AtomArrayStack
            The array or stack to be saved into this file.
            Must have an associated :class:`BondList`.
        """
        
        header_lines = []
        header_lines.append(self.lines[0])
        header_lines.append(self.lines[1])
        header_lines.append(self.lines[2])

        
 
        header_lines = self.lines[:N_HEADER]

        
        if isinstance(atoms, AtomArray):
            self.lines = header_lines + write_structure_to_ctab(atoms)
            self.lines += ["$$$$"]


        elif isinstance(atoms, AtomArrayStack):
        
            for i, atoms_i in enumerate(atoms):

                header_lines = self.lines[:N_HEADER]   
                                                      
                if i == 0:
                    self.lines  = header_lines
                else:
                    self.lines += header_lines                    

                processed_lines = write_structure_to_ctab(atoms_i)                
                self.lines += processed_lines                                       
                self.lines += ["$$$$"]                                                  

    def get_metainformation(self):
        """
        Set the :class:`AtomArray` for the file.
        
        Returns
        -------   
        annotations: dict
            This dictionary contains all the metainformation given in lines 
            like:
                >  <MODEL>
                1     
            Or it contains multiple dictionaries if a multi file model with
            meta information entries has been loaded.                         
        """
    
        meta_info = {}       
        mod_start_lines, m_end_lines, mod_end_lines = self.__get_model_lines()

        i_start = 0
        for i in range(len(mod_end_lines)):
                        
            sub_meta_info = {}
            
            line_sub_model = self.lines[
                mod_start_lines[i]:mod_end_lines[i]+1
            ]           
                        
            annotation_line_indices = [
                i for i in range(len(line_sub_model)) if ">" in line_sub_model[i]
            ]


            for j, indx in enumerate(annotation_line_indices):
                annotation_line = line_sub_model[indx]

                if "<" not in annotation_line or ">" not in annotation_line:
                    msg  = "The annotation tag is not defined in the expected"
                    msg += " format <TAGNAME>. Can not parse metainformation."
                    msg += " Line was :: \n\n " +str(annotation_line)                    
                    raise BadStructureError(msg)                     
                
                annotation_line = annotation_line.strip().strip(">")
                annotation_tag = annotation_line.strip().strip("<").strip()              
                                                                                      
                

                annotation_content = ""
                if j < len(annotation_line_indices)-1:
                    annotation_content = line_sub_model[int(indx+1):annotation_line_indices[j+1]]
                else:          
                    annotation_content = line_sub_model[int(indx+1):]
                    
                line_filter = lambda x: len(x) != 0 and "$$$$" not in x                    
                annotation_content = [
                    x for x in annotation_content if line_filter(x)
                ]
                annotation_content = '\n'.join(annotation_content)                                        
                sub_meta_info[annotation_tag] = annotation_content                        
                                 
            
            meta_info["model_"+str(i)]=sub_meta_info               

        if len(list(meta_info.keys()))==1:
            return meta_info["model_0"]
        else:
            return meta_info  
                                    
            
    def set_metainformation(self, meta_information):        
        """
        Set the meta information for the SD File.
        
        Parameters
        ----------        
        annotations: dict
            This dictionary contains all the metainformation given in lines 
            like:
                >  <MODEL>
                1  
            Either a single dictionary with MODEL:value pairs (if only a single
            structure is stored) or a dictionary of dictionaries where each key 
            indicates a model and the value is the according model specific 
            meta_information dictionary (which might also be empty):
            
            {
                "model_0": {"Tag1":Value1,.... }, 
                "model_1": {"Tag1":Value1',.... }, 
                ...
            }                
        """
                   
        if len(self.lines) == N_HEADER:
            msg  = "Meta Information can only be written afte a structure has"
            msg += "been set"
            raise BadStructureError(msg)
            
    
        header_lines = self.lines[:N_HEADER]        
        mod_start_lines, m_end_lines, mod_end_lines = self.__get_model_lines()
        
        if len(mod_end_lines) == 1:
        
            # local helper function for checking the integrity
            # of the given meta_information dictionary with regards
            # to a multimodel file
            def is_correct_meta_information_dict(x_dict):
                cond = type(x_dict) is dict                            
                return cond                                         
                

            if not is_correct_meta_information_dict(meta_information):
                msg += "Provided meta_information variable of wrong type:\n"
                msg += "Given :: "+str(meta_information)
                raise ValueError(msg)           

            if len(meta_information.keys()) != 0:
                for i, x in enumerate(meta_information.keys()):
                    if i==0 and self.lines[-1] == "$$$$":
                        self.lines[-1]="> <" +str(x) + "> "
                    else:     
                        self.lines.append("> <" +str(x) + "> ")                                       
                    self.lines.append(meta_information[x])
                self.lines.append("$$$$")                    

        else:            
            if meta_information is not None:    
            
            
                # local helper function for checking the integrity
                # of the given meta_information dictionary with regards
                # to a multimodel file
                def is_correct_meta_information_dict(x_dict):
                    cond = type(x_dict) is dict                    
                    cond = cond and (len(mod_end_lines) == len(x_dict.keys()))
                    n_keys = -1
                    for k in x_dict.keys():
                    
                        cond = cond and type(x_dict[k]) is dict
                    
                        if n_keys == -1:
                            n_keys = len(x_dict[k].keys())
                        else:
                            sub_keys = x_dict[k].keys()
                            cond = cond and len(sub_keys) == n_keys
                            
                    return cond                                         
                    

                if not is_correct_meta_information_dict(meta_information):
                    msg  = "Provided meta information dictionary needs to have"
                    msg += "one key for each model stored in the SD File."
                    msg += "Where und each such key a dictionary containing the"
                    msg += "meta information for the according model is stored"
                    msg += "\nGiven dictionary was :: "+str(meta_information)
                    raise ValueError(msg)           
                                                                
                for i, key in enumerate(meta_information.keys()):
                    sub_annotations = meta_information[key]
                    model_lines = self.__get_model_lines()
                    mod_start_lines, m_end_lines, mod_end_lines = model_lines

                    i_model_start   = mod_start_lines[i]
                    i_m_end         = m_end_lines[i]
                    i_model_end     = mod_end_lines[i]                      
                    
                    sub_dict = meta_information[key]
                    
                    if len(sub_dict.keys()) != 0:
                        sub_meta_info_lines = []
                        for subkey in sub_dict.keys():                
                            sub_meta_info_lines.append("> <" +str(subkey) + "> ")
                            sub_meta_info_lines.append(sub_dict[subkey])
                            
                        # need to add written meta information lines right
                        # after structure lines                         
                        lines_old = self.lines
                        structure_old = self.lines[i_model_start:i_m_end]                    
                        
                        self.lines = lines_old[:i]
                        self.lines  = lines_old[:i_model_start]
                        self.lines += structure_old
                        self.lines += ["M  END"]                        
                        self.lines += sub_meta_info_lines 

                        self.lines += lines_old[i_model_end:]
                                                                                  


def _get_ctab_lines(lines):
    for i, line in enumerate(lines):
        if line.startswith("M  END"):
            return lines[N_HEADER:i+1]
    return lines[N_HEADER:]
